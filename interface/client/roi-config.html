<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ROI Configuration - Parking Detection</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4A90E2;
            --primary-hover-color: #3A7BCD;
            --secondary-color: #6c757d;
            --secondary-hover-color: #5a6268;
            --success-color: #28a745;
            --success-hover-color: #218838;
            --danger-color: #dc3545;
            --danger-hover-color: #c82333;
            --background-color: #f0f2f5;
            --card-background: #ffffff;
            --text-color: #333;
            --border-color: #e0e0e0;
            --shadow-light: 0 2px 4px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.1);
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1, h2, h3, p {
            text-align: center;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        p {
            font-size: 1.1em;
            color: #555;
            margin-bottom: 20px;
        }

        .container { /* General purpose container, not used for main layout anymore */
            width: 95%;
            max-width: 1600px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--card-background);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-light);
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 18px;
            font-size: 16px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 1000;
        }

        .back-btn:hover {
            background-color: var(--secondary-hover-color);
            transform: translateY(-2px);
        }

        .back-btn svg {
            width: 18px;
            height: 18px;
        }

        /* --- Main Dashboard Layout --- */
        .main-dashboard-container {
            display: flex;
            flex-wrap: wrap; /* Allows columns to wrap on smaller screens */
            gap: 20px;
            width: 95%;
            max-width: 1600px; /* Match overall page max-width */
        }

        .dashboard-left {
            flex: 2; /* Takes more space for the canvas */
            min-width: 450px; /* Ensures canvas column doesn't get too small */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dashboard-right {
            flex: 1; /* Takes less space for controls and JSON */
            min-width: 350px; /* Ensures right column doesn't get too small */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        /* --- End Main Dashboard Layout --- */

        #controls, #video-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap; 
            gap: 15px;
        }

        /* --- Specific layout for Controls section --- */
        #controls {
            justify-content: flex-start; /* Align content to start */
            align-items: flex-start; /* Align items to their start, for consistent rows */
            flex-direction: column; /* Stack main groups vertically */
            gap: 20px; /* Space between main control groups */
        }

        #controls > div {
            display: flex;
            flex-wrap: wrap; /* Allow elements within groups to wrap */
            gap: 15px; /* Space between elements within a group */
            width: 100%; /* Take full width of parent */
            align-items: center; /* Vertically center items within their row */
        }
        
        .video-loader-group {
            border-bottom: 1px solid var(--border-color); /* Separator */
            padding-bottom: 15px;
            margin-bottom: -5px; /* Adjust margin to compensate for padding-bottom */
        }

        .roi-upload-section {
            border-top: 1px solid var(--border-color); /* Separator */
            padding-top: 15px;
            margin-top: -5px; /* Adjust margin to compensate for padding-top */
        }
        /* --- End specific layout for Controls section --- */


        label {
            font-weight: 500;
            color: #555;
            white-space: nowrap;
        }

        input[type="file"] {
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: #f9f9f9;
            cursor: pointer;
            flex-grow: 1; /* Allows input to take available space */
            min-width: 150px; /* Ensures input doesn't get too small */
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: var(--primary-color);
            color: white;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background-color: var(--primary-hover-color);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        #resetButton {
            background-color: var(--danger-color);
        }

        #resetButton:hover {
            background-color: var(--danger-hover-color);
        }

        #saveToServerButton {
            background-color: var(--success-color);
        }

        #saveToServerButton:hover {
            background-color: var(--success-hover-color);
        }

        #playPauseButton {
            width: 80px; /* Fixed width for consistent button size */
            justify-content: center;
        }

        #seekBar {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 8px;
            background: #ddd;
            border-radius: 50px; /* More rounded seek bar */
            outline: none;
            transition: background 0.2s ease;
        }

        #seekBar::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: grab;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.3);
            transition: background 0.3s ease;
        }

        #seekBar:hover::-webkit-slider-thumb {
            background: var(--primary-hover-color);
        }

        #timeDisplay {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.95em;
            color: #555;
            white-space: nowrap;
            min-width: 100px;
            text-align: right;
        }

        #canvas-container {
            min-width: 400px; 
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            overflow: hidden; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Canvas navbar styles */
        .canvas-navbar {
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            padding: 15px 20px;
            margin-bottom: 10px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: flex-start;
        }

        .canvas-navbar button {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            min-height: 36px;
        }

        .canvas-navbar button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .canvas-navbar button:active {
            transform: translateY(0);
        }

        /* Specific button colors for navbar */
        .canvas-navbar #undoButton {
            background-color: var(--secondary-color);
            color: white;
        }

        .canvas-navbar #undoButton:hover {
            background-color: var(--secondary-hover-color);
        }

        .canvas-navbar #resetButton {
            background-color: var(--danger-color);
            color: white;
        }

        .canvas-navbar #resetButton:hover {
            background-color: var(--danger-hover-color);
        }

        .canvas-navbar #downloadButton {
            background-color: var(--primary-color);
            color: white;
        }

        .canvas-navbar #downloadButton:hover {
            background-color: var(--primary-hover-color);
        }

        .canvas-navbar #saveToServerButton {
            background-color: var(--success-color);
            color: white;
        }

        .canvas-navbar #saveToServerButton:hover {
            background-color: var(--success-hover-color);
        }

        .canvas-navbar #addToServerButton {
            background-color: #17a2b8; /* Teal color for "add" action */
            color: white;
        }

        .canvas-navbar #addToServerButton:hover {
            background-color: #138496;
        }

        .canvas-navbar svg {
            width: 16px;
            height: 16px;
        }

        #canvas {
            border: 2px solid var(--border-color);
            cursor: crosshair;
            max-width: 100%;
            height: auto;
            display: block;
            border-radius: 8px; 
        }

        #output-container {
            min-width: 300px; 
            background: var(--card-background);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #output-json {
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 8px;
            min-height: 150px; 
            max-height: 300px; 
            overflow-y: auto; 
            border: 1px solid var(--border-color);
        }

        /* ROI List Styles */
        #roi-list-container {
            margin-top: 20px;
        }

        #roi-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .roi-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .roi-item:hover {
            background-color: #e9ecef;
        }

        .roi-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .roi-id {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1.1em;
        }

        .roi-coordinates {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.8em;
            color: #666;
        }

        .roi-delete-btn {
            padding: 6px 12px;
            font-size: 0.9em;
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 70px;
            justify-content: center;
        }

        .roi-delete-btn:hover {
            background-color: var(--danger-hover-color);
        }

        .roi-delete-btn svg {
            width: 14px;
            height: 14px;
        }

        .no-roi-message {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 20px 0;
        }

        /* Hide the original video as we'll draw it on canvas */
        #videoPlayer {
            display: none;
        }

        .instructions {
            background: var(--card-background);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            margin-top: 20px; /* Space from content above it */
            width: 95%; /* Match container width */
            max-width: 1600px; /* Match container max-width */
        }

        .instructions h3 {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: left;
        }

        .instructions ul {
            margin: 10px 0 0 0;
            padding-left: 25px;
            list-style-type: disc;
            color: #555;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .status-message {
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--shadow-light);
            width: 95%; /* Match container width */
            max-width: 1600px; /* Match container max-width */
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .main-dashboard-container {
                flex-direction: column; /* Stack columns vertically */
                align-items: center; /* Center items in column mode */
            }
            .dashboard-left, .dashboard-right {
                min-width: unset; /* Remove min-width constraints */
                width: 100%; /* Take full width */
                flex: auto; /* Allow them to size automatically */
            }
            /* Adjust individual card max-widths if needed */
            #canvas-container, #controls, #video-controls, #output-container {
                max-width: 100%; /* Ensure cards don't exceed column width */
            }
        }

        @media (max-width: 900px) {
            .canvas-navbar {
                padding: 12px 16px;
                gap: 8px;
            }
            
            .canvas-navbar button {
                padding: 6px 12px;
                font-size: 13px;
                gap: 4px;
            }
            
            .canvas-navbar svg {
                width: 15px;
                height: 15px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            h1 {
                font-size: 2em;
            }
            p {
                font-size: 1em;
            }
            .back-btn {
                top: 15px;
                left: 15px;
                padding: 8px 15px;
                font-size: 14px;
            }
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
            /* Controls and video controls already use flex-direction: column; on small screens */
            #controls > div {
                flex-direction: column;
                align-items: stretch; /* Stretch items to fill width */
            }
            .roi-upload-section input[type="file"] {
                width: 100%; /* Full width for file input on small screens */
            }
            
            /* Adjust navbar for mobile */
            .canvas-navbar {
                padding: 12px 15px;
                gap: 6px;
                justify-content: center;
            }
            
            .canvas-navbar button {
                padding: 6px 10px;
                font-size: 11px;
                gap: 3px;
                min-height: 32px;
                flex: 1;
                justify-content: center;
                max-width: 80px; /* Limit button width on mobile */
            }
            
            .canvas-navbar svg {
                width: 12px;
                height: 12px;
            }
        }
    </style>
    <script src="route-config.js"></script>
    <script src="router.js"></script>
</head>
<body>
    <button class="back-btn" onclick="navigation.goHome()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12.707 17.293a1 1 0 001.414-1.414L11.414 13H18a1 1 0 000-2h-6.586l2.707-2.707a1 1 0 00-1.414-1.414l-4 4a1 1 0 000 1.414l4 4z"/></svg>
        Back to Main
    </button>
    
    <h1>ROI Configuration Tool üÖøÔ∏è</h1>
    <p>Upload a video or image, pause at desired frame, then mark parking spot regions.</p>
    
    <div class="status-message" id="statusMessage"></div>

    <div class="main-dashboard-container">
        <div class="dashboard-left">
            <div class="canvas-navbar">
                <button id="undoButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12.5 8c-2.65 0-5.19 1.23-6.76 3.23l-1.64-1.64a1 1 0 00-1.41 1.41l3.5 3.5a1 1 0 001.41 0l3.5-3.5a1 1 0 00-1.41-1.41l-1.66 1.66C9.84 9.4 11.12 8.75 12.5 8.75c2.62 0 4.75 2.13 4.75 4.75S15.12 18.25 12.5 18.25a5.52 5.52 0 01-3.66-1.37A1 1 0 008 17.8c-.35.34-.48.86-.33 1.35.15.49.59.85 1.14.85a7.52 7.52 0 004.29-1.29 7.75 7.75 0 003.75-6.52c0-4.28-3.47-7.75-7.75-7.75z"/></svg>
                    Undo
                </button>
                <button id="resetButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12 4C7.58 4 4 7.58 4 12s3.58 8 8 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.3-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.09 2.09C16.89 4.78 14.59 4 12 4z"/></svg>
                    Reset
                </button>
                <button id="downloadButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Download
                </button>
                <button id="addToServerButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    Add to Server
                </button>
                <button id="saveToServerButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M17 3H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H9V5h6v4z"/></svg>
                    Replace Server
                </button>
            </div>
            <div id="canvas-container" class="card">
                <canvas id="canvas"></canvas>
                <video id="videoPlayer"></video>
            </div>
            <div id="video-controls" class="card">
                <button id="playPauseButton">
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="pauseIcon" style="display:none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    Play
                </button>
                <input type="range" id="seekBar" value="0" step="0.01" />
                <span id="timeDisplay">00:00 / 00:00</span>
            </div>
        </div>

        <div class="dashboard-right">
            <div class="card" id="controls">
                <div class="video-loader-group">
                    <label for="videoLoader">Choose Media (Video/Image):</label>
                    <input type="file" id="videoLoader" accept="video/*,image/*" /> 
                </div>
                
                <div class="roi-upload-section">
                    <label for="roiFileUpload">Upload ROI JSON:</label>
                    <input type="file" id="roiFileUpload" accept=".json" />
                    <button id="uploadRoiButton">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"/></svg>
                        Upload & Apply
                    </button>
                </div>
            </div>

            <div id="output-container" class="card">
                <h2>Parking Spots JSON</h2>
                <pre id="output-json"><code>[]</code></pre>
            </div>

            <div class="card" id="roi-list-container">
                <h2>ROI List</h2>
                <div id="roi-list">
                    <p class="no-roi-message">No ROIs created yet. Click on the canvas to add parking spots.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const videoLoader = document.getElementById("videoLoader"); // File input for media
        const video = document.getElementById("videoPlayer"); // Video element
        const playPauseButton = document.getElementById("playPauseButton");
        const playIcon = document.getElementById("playIcon");
        const pauseIcon = document.getElementById("pauseIcon");
        const seekBar = document.getElementById("seekBar");
        const timeDisplay = document.getElementById("timeDisplay");
        const videoControlsContainer = document.getElementById("video-controls"); // Reference to the video controls div

        const outputJson = document.getElementById("output-json").querySelector("code");
        const undoButton = document.getElementById("undoButton");
        const resetButton = document.getElementById("resetButton");
        const downloadButton = document.getElementById("downloadButton");
        const addToServerButton = document.getElementById("addToServerButton");
        const saveToServerButton = document.getElementById("saveToServerButton");
        const statusMessage = document.getElementById("statusMessage");
        const roiFileUpload = document.getElementById("roiFileUpload");
        const uploadRoiButton = document.getElementById("uploadRoiButton");
        const roiList = document.getElementById("roi-list");

        let spots = [];
        let currentPoints = [];
        let spotId = 1;

        let currentMedia = null; // Stores either the video element or an Image object
        let isVideoMedia = false; // Flag to track if the current media is a video

        const LOCAL_STORAGE_KEY = 'roiConfiguration'; // Key for local storage

        // Helper to update visibility of video-specific controls
        function updateVideoControlsVisibility() {
            if (isVideoMedia) {
                videoControlsContainer.style.display = 'flex'; // Show controls for video
            } else {
                videoControlsContainer.style.display = 'none'; // Hide controls for image
            }
        }

        // Save current ROI data to local storage
        function saveRoiToLocalStorage() {
            const jsonString = outputJson.textContent;
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, jsonString);
                // showStatus("ROI saved to browser storage.", "info"); // Can be noisy, use sparingly
            } catch (e) {
                console.error("Error saving to local storage:", e);
                showStatus("Error saving ROI to browser storage.", "error");
            }
        }

        // Load media (video or image)
        videoLoader.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) {
                return;
            }

            const mediaURL = URL.createObjectURL(file);

            if (file.type.startsWith('video/')) {
                isVideoMedia = true;
                currentMedia = video; // Set currentMedia to the video element
                video.src = mediaURL;
                // loadedmetadata event will handle canvas drawing and controls update for video
            } else if (file.type.startsWith('image/')) {
                isVideoMedia = false;
                // Reset video element to prevent old video playing
                video.src = ''; 
                video.load(); // Ensure video element is reset

                const img = new Image();
                img.onload = () => {
                    currentMedia = img; // Set currentMedia to the loaded Image object
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    resetAll(false); // Reset ROI, but no status message for media load
                    redrawCanvas(); // Draw the image to canvas
                    updateVideoControlsVisibility(); // Hide video controls
                    showStatus("Image loaded successfully. Mark ROIs.", "success");
                };
                img.onerror = () => {
                    showStatus("Error loading image file.", "error");
                    currentMedia = null;
                    isVideoMedia = false;
                    updateVideoControlsVisibility();
                };
                img.src = mediaURL;
            } else {
                showStatus("Unsupported file type. Please upload a video or image.", "error");
                currentMedia = null;
                isVideoMedia = false;
                updateVideoControlsVisibility();
            }
        });

        // Setup after video metadata is loaded (only for videos)
        video.addEventListener("loadedmetadata", () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            seekBar.max = video.duration;
            seekBar.value = 0; // Reset seek bar to start
            updateTimeDisplay();
            resetAll(false); // Reset ROI, but no status message for media load
            redrawCanvas(); // Draw first frame
            updateVideoControlsVisibility(); // Show video controls
            showStatus("Video loaded successfully. Pause to mark ROIs.", "success");
        });

        // Draw background media (image or video frame) to canvas
        function drawBackgroundMedia() {
            if (!currentMedia) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear if no media
                return;
            }

            if (isVideoMedia) {
                if (!video.paused || video.readyState > 1) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }
            } else {
                // If it's an image, draw the image
                ctx.drawImage(currentMedia, 0, 0, canvas.width, canvas.height);
            }
        }

        // Main function to redraw canvas
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackgroundMedia(); // Call the unified background drawing function

            spots.forEach((spot) => {
                drawPolygon(spot.points, "#00ff00", 2); // Green for saved spots
                drawText(spot.id, spot.points);
            });

            currentPoints.forEach((p) => drawDot(p, "#ff0000")); // Red for current points
            if (currentPoints.length > 1) {
                drawPolygon(currentPoints, "#ffff00", 2, false); // Yellow for drawing current polygon
            }
        }

        // Animation loop when video is playing
        function animate() {
            if (!isVideoMedia || video.paused || video.ended) {
                return;
            }
            redrawCanvas();
            requestAnimationFrame(animate);
        }

        // Video Controls (only active if isVideoMedia is true)
        playPauseButton.addEventListener("click", () => {
            if (!currentMedia) {
                showStatus("Please upload a video or image first!", "error");
                return;
            }
            if (!isVideoMedia) { // If it's an image, play/pause has no effect
                showStatus("This is an image, video controls are not applicable.", "info");
                return;
            }

            if (video.paused) {
                video.play();
                playPauseButton.textContent = "Pause";
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'inline-block';
                requestAnimationFrame(animate);
            } else {
                video.pause();
                playPauseButton.textContent = "Play";
                playIcon.style.display = 'inline-block';
                pauseIcon.style.display = 'none';
            }
        });

        seekBar.addEventListener("input", () => {
            if (!isVideoMedia || !currentMedia) return;
            video.pause();
            playPauseButton.textContent = "Play";
            playIcon.style.display = 'inline-block';
            pauseIcon.style.display = 'none';
            video.currentTime = seekBar.value;
        });

        video.addEventListener("timeupdate", () => {
            if (!isNaN(video.duration)) { // Ensure duration is available
                seekBar.value = video.currentTime;
            }
            redrawCanvas(); // Update canvas when seeking
            updateTimeDisplay();
        });

        video.addEventListener("pause", () => {
            playPauseButton.textContent = "Play";
            playIcon.style.display = 'inline-block';
            pauseIcon.style.display = 'none';
            redrawCanvas(); // Ensure canvas is updated on pause
        });

        video.addEventListener("play", () => {
            playPauseButton.textContent = "Pause";
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'inline-block';
            animate();
        });

        function formatTime(seconds) {
            if (isNaN(seconds)) return "00:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${String(min).padStart(2, "0")}:${String(sec).padStart(2, "0")}`;
        }

        function updateTimeDisplay() {
            timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
        }

        // Event listener for canvas clicks
        canvas.addEventListener("click", (e) => {
            if (!currentMedia) {
                showStatus("Please upload a video or image first!", "error");
                return;
            }
            // Only require pause if it's a video
            if (isVideoMedia && !video.paused) {
                showStatus("Please pause the video first to mark points!", "error");
                return;
            }

            const rect = canvas.getBoundingClientRect();
            // Calculate scale factor to translate click coordinates from CSS pixels to canvas pixels
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);

            currentPoints.push({ x, y });
            if (currentPoints.length === 4) {
                spots.push({ id: spotId, points: [...currentPoints] });
                spotId++;
                currentPoints = [];
                updateOutput();
                showStatus(`Parking spot ${spotId - 1} added.`, "success");
            } else {
                showStatus(`Click ${4 - currentPoints.length} more times to complete the spot.`, "success");
            }
            redrawCanvas();
        });

        // Drawing functions (remain mostly the same)
        function drawPolygon(points, color, lineWidth, closed = true) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            if (closed) {
                ctx.closePath();
            }
            ctx.stroke();
        }

        function drawDot(point, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawText(id, points) {
            const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            ctx.fillStyle = "white";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText(id, centerX, centerY); // Outline for better visibility
            ctx.fillText(id, centerX, centerY);
        }

        // Updated to call saveRoiToLocalStorage and updateRoiList
        function updateOutput() {
            const formattedSpots = spots.map((spot) => ({
                id: spot.id,
                points: spot.points.map((p) => [p.x, p.y]),
            }));
            const jsonString = JSON.stringify(formattedSpots, null, 2);
            outputJson.textContent = jsonString;
            saveRoiToLocalStorage(); // Save to local storage whenever output changes
            updateRoiList(); // Update the ROI list display
        }

        // Update ROI list display
        function updateRoiList() {
            if (spots.length === 0) {
                roiList.innerHTML = '<p class="no-roi-message">No ROIs created yet. Click on the canvas to add parking spots.</p>';
                return;
            }

            roiList.innerHTML = spots.map(spot => {
                const coordsPreview = spot.points.slice(0, 2).map(p => `(${p.x},${p.y})`).join(' ');
                return `
                    <div class="roi-item">
                        <div class="roi-info">
                            <div class="roi-id">Parking Spot ${spot.id}</div>
                            <div class="roi-coordinates">${coordsPreview}${spot.points.length > 2 ? '...' : ''}</div>
                        </div>
                        <button class="roi-delete-btn" onclick="deleteRoi(${spot.id})">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                            Delete
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Delete specific ROI
        function deleteRoi(id) {
            const spotIndex = spots.findIndex(spot => spot.id === id);
            if (spotIndex !== -1) {
                spots.splice(spotIndex, 1);
                updateOutput();
                redrawCanvas();
                showStatus(`Parking spot ${id} deleted.`, "success");
            }
        }

        // Button event listeners
        undoButton.addEventListener("click", () => {
            if (currentPoints.length > 0) {
                currentPoints.pop();
                showStatus("Last point undone.", "success");
            } else if (spots.length > 0) {
                spots.pop();
                spotId--;
                showStatus(`Parking spot ${spotId} removed.`, "success");
            } else {
                showStatus("Nothing to undo.", "error");
            }
            updateOutput(); // This will trigger saveRoiToLocalStorage
            redrawCanvas();
        });

        resetButton.addEventListener("click", () => resetAll(true));

        // Updated to clear local storage and update ROI list
        function resetAll(showMsg = true) {
            spots = [];
            currentPoints = [];
            spotId = 1;
            updateOutput(); // This will save an empty array to local storage and update ROI list
            if (currentMedia) { 
                redrawCanvas();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
            }
            if (showMsg) {
                showStatus("All parking spots reset.", "success");
            }
        }

        downloadButton.addEventListener("click", () => {
            const jsonData = outputJson.textContent;
            if (!jsonData || jsonData.trim() === "[]") {
                showStatus("No ROI data to download!", "error");
                return;
            }
            const blob = new Blob([jsonData], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "parking_spots.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showStatus("ROI data downloaded successfully!", "success");
        });

        // Save ROI configuration to server (replace server data with current state)
        saveToServerButton.addEventListener("click", async () => {
            const jsonData = outputJson.textContent;
            if (!jsonData || jsonData.trim() === "[]") {
                showStatus("No ROI data to save! Draw or upload first.", "error");
                return;
            }

            try {
                showStatus("Saving current ROI state to server...", "info");
                
                // Send current data directly to server (replaces existing data)
                const currentSpots = JSON.parse(jsonData);
                await sendRoiToServer(currentSpots, `${currentSpots.length} ROI(s) saved to server.`);
                
            } catch (error) {
                console.error('Error in save process:', error);
                showStatus(`Error saving ROI: ${error.message}`, "error");
            }
        });

        // Add ROI configuration to server (append to existing data)
        addToServerButton.addEventListener("click", async () => {
            const jsonData = outputJson.textContent;
            if (!jsonData || jsonData.trim() === "[]") {
                showStatus("No ROI data to add! Draw or upload first.", "error");
                return;
            }

            try {
                showStatus("Getting existing ROI data from server...", "info");
                
                // First, get existing data from server
                let existingSpots = [];
                try {
                    const response = await fetch(`${API_BASE}/get-roi`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.parking_spots && Array.isArray(data.parking_spots)) {
                            existingSpots = data.parking_spots;
                        }
                    }
                } catch (error) {
                    console.log('Could not fetch existing data, proceeding with current data only:', error);
                }

                // Combine existing and current data, avoiding duplicates by ID
                const currentSpots = JSON.parse(jsonData);
                const existingIds = existingSpots.map(spot => spot.id);
                const newSpots = currentSpots.filter(spot => !existingIds.includes(spot.id));
                const combinedSpots = [...existingSpots, ...newSpots];

                // If no new spots to add
                if (newSpots.length === 0) {
                    showStatus("All ROIs already exist on server. No new data to add.", "info");
                    return;
                }

                // Send combined data to server
                await sendRoiToServer(combinedSpots, `${newSpots.length} new ROI(s) added to existing ${existingSpots.length} ROI(s) on server.`);
                
            } catch (error) {
                console.error('Error in add process:', error);
                showStatus(`Error adding ROI: ${error.message}`, "error");
            }
        });

        // Upload ROI JSON from file and add to existing server data
        uploadRoiButton.addEventListener("click", async () => {
            const file = roiFileUpload.files[0];
            if (!file) {
                showStatus("Please select a JSON file to upload.", "error");
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const uploadedData = JSON.parse(e.target.result);
                    if (!Array.isArray(uploadedData) || uploadedData.some(spot => !spot.id || !Array.isArray(spot.points) || spot.points.some(p => !Array.isArray(p) || p.length !== 2))) {
                        throw new Error("Invalid JSON format. Expected an array of objects with 'id' and 'points' (array of [x,y] arrays).");
                    }
                    
                    // Load uploaded data into current view (replacing current spots)
                    const newSpots = uploadedData.map(spot => ({
                        id: spot.id,
                        points: spot.points.map(p => ({ x: p[0], y: p[1] }))
                    }));

                    spots = newSpots;
                    spotId = spots.length > 0 ? Math.max(...spots.map(s => s.id)) + 1 : 1;
                    currentPoints = [];
                    updateOutput(); // This will trigger saveRoiToLocalStorage and update ROI list
                    redrawCanvas();
                    showStatus("ROI data loaded from file. Adding to existing server data...", "info");
                    
                    // Get existing server data and merge
                    let existingSpots = [];
                    try {
                        const response = await fetch(`${API_BASE}/get-roi`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.parking_spots && Array.isArray(data.parking_spots)) {
                                existingSpots = data.parking_spots;
                            }
                        }
                    } catch (error) {
                        console.log('Could not fetch existing data, proceeding with uploaded data only:', error);
                    }

                    // Combine uploaded and existing data, handling ID conflicts
                    const existingIds = existingSpots.map(spot => spot.id);
                    const maxExistingId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
                    
                    // Reassign IDs for uploaded spots that conflict with existing ones
                    let nextAvailableId = maxExistingId + 1;
                    const adjustedUploadedData = uploadedData.map(spot => {
                        if (existingIds.includes(spot.id)) {
                            const newId = nextAvailableId++;
                            console.log(`Reassigning ROI ID ${spot.id} to ${newId} to avoid conflict`);
                            return { ...spot, id: newId };
                        }
                        return spot;
                    });

                    const combinedSpots = [...existingSpots, ...adjustedUploadedData];
                    await sendRoiToServer(combinedSpots, `${adjustedUploadedData.length} ROI(s) from file added to existing ${existingSpots.length} ROI(s) on server.`);

                } catch (error) {
                    console.error('Error processing uploaded file:', error);
                    showStatus(`Error processing uploaded file: ${error.message}`, "error");
                }
            };
            reader.readAsText(file);
        });

        // Centralized function to send ROI data to server
        async function sendRoiToServer(roiData, customMessage = null) {
            try {
                showStatus("Saving ROI configuration to server...", "info");
                const response = await fetch(`${API_BASE}/update-roi`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ parking_spots: roiData })
                });

                if (response.ok) {
                    const result = await response.json();
                    const message = customMessage || "ROI configuration saved successfully to server!";
                    showStatus(message, "success");
                    console.log('ROI saved:', result);
                    updateOutput(); // Ensure local storage is updated after successful server save
                } else {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to save ROI configuration');
                }
            } catch (error) {
                console.error('Error saving ROI:', error);
                showStatus(`Error saving ROI: ${error.message}`, "error");
            }
        }

        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            
            clearTimeout(statusMessage.hideTimeout); 
            statusMessage.hideTimeout = setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        function goBack() {
            navigation.goHome();
        }

        // Make deleteRoi function globally accessible
        window.deleteRoi = deleteRoi;

        // Initialize routing for this page
        window.addEventListener('load', () => {
            // Set current route context
            router.currentRoute = '/roi-config';
        });

        // Load existing ROI configuration on page load
        window.addEventListener('load', async () => {
            updateVideoControlsVisibility(); // Initialize video controls visibility (hidden by default for image support)

            let loadedFromLocalStorage = false;
            try {
                const storedRoi = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedRoi) {
                    const parsedData = JSON.parse(storedRoi);
                    // Basic validation for local storage data
                    if (Array.isArray(parsedData) && !parsedData.some(spot => !spot.id || !Array.isArray(spot.points) || spot.points.some(p => !Array.isArray(p) || p.length !== 2))) {
                        
                        spots = parsedData.map(spot => ({
                            id: spot.id,
                            points: spot.points.map(p => ({ x: p[0], y: p[1] }))
                        }));
                        spotId = spots.length > 0 ? Math.max(...spots.map(s => s.id)) + 1 : 1;
                        updateOutput(); // This will refresh outputJson, save back to localStorage, and update ROI list
                        showStatus("Loaded ROI configuration from browser storage.", "success");
                        loadedFromLocalStorage = true;
                    } else {
                        console.warn("Invalid ROI data found in local storage, clearing it.");
                        localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear invalid data
                    }
                }
            } catch (error) {
                console.error("Error parsing ROI from local storage:", error);
                showStatus("Error loading ROI from browser storage. Data might be corrupted.", "error");
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted data
            }

            // Only attempt to load from server if local storage was empty or invalid
            if (!loadedFromLocalStorage) {
                try {
                    const response = await fetch(`${API_BASE}/get-roi`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.parking_spots && data.parking_spots.length > 0) {
                            spots = data.parking_spots.map(spot => ({
                                id: spot.id,
                                points: spot.points.map(p => ({ x: p[0], y: p[1] }))
                            }));
                            spotId = Math.max(...spots.map(s => s.id)) + 1;
                            updateOutput(); // This will refresh outputJson, save to localStorage, and update ROI list
                            showStatus("Loaded existing ROI configuration from server.", "success");
                        } else {
                            showStatus("No existing ROI configuration found on server.", "info");
                        }
                    } else {
                        showStatus("Could not fetch existing ROI configuration from server.", "warning");
                    }
                } catch (error) {
                    console.log('API unreachable on load:', error);
                    showStatus("Could not connect to backend to load ROI configuration.", "error");
                }
            }

            // Redraw canvas after all loading attempts
            if (currentMedia) {
                redrawCanvas();
            }
        });
    </script>
</body>
</html>